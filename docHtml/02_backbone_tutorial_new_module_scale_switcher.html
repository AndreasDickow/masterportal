<h2>Tutorial: Ein neues Tool erstellen (Scale-Switcher)</h2>
<p>Eine Schritt für Schritt Dokumentation zur Erstellung eines neuen Tools (Moduls).</p>
<h3>Beispiel Anforderung</h3>
<p>Wir wollen ein Tool schreiben, über welches man den Kartenmaßstab steuern kann. Dabei soll über ein Drop-Down-Menü der Maßstab ausgewählt werden. Sobald der Maßstab gesetzt wurde, soll sich die Karte anpassen.
Darüber hinaus soll unser Tool auf Änderungen des Kartenmaßstabes reagieren und den entsprechend aktuellen Maßstab im Drop-Down-Menu anzeigen.</p>
<h3>Neues Tool anlegen</h3>
<p>In das Verzeichnis “modules -&gt; tools” wechseln und einen neuen Ordner erstellen. Aus dem Ordnernamen sollte ersichtlich sein, um was für ein Tool es sich dabei handelt - z.B. “scale”. Die für dieses Tool benötigten Dateien anlegen. In der View (view.js) wird auf Interaktion mit dem Nutzer reagiert und das Tool neu gerendert. Dazu wird das Template (template.html) benötigt, welches den Bauplan des Tools enthält. Im Model (model.js) werden die Daten und deren Logik vorgehalten. Stylingparameter werden in der style.scss konfiguriert.</p>
<pre><code>-  modules
   | -&gt; tools
   |    |-&gt; scale
   |    |    | -&gt; view.js
   |    |    | -&gt; model.js
   |    |    | -&gt; template.html
   |    |    | -&gt; style.css
</code></pre>
<h3>Scale View erstellen und zurückgeben</h3>
<p>Datei <em>modules/tools/scale/view.js</em> öffnen und die View mit folgendem Standardschema erzeugen.</p>
<pre><code class="language-js">
const ScaleView = Backbone.View.extend({
      // wird aufgerufen wenn die View erstellt wird
      initialize: function () {
      }
    });

export default ScaleView;

</code></pre>
<h3>Scale View initialisieren</h3>
<p>In die datei <em>js/app.js</em> wechseln, Scale View importieren und initialiseren. Darauf achten, dass das Tool grundsätzlich erst nach dem Core initialsiert werden. (Dies gilt für jedes Modul) Das Initialsieren eines Tools erfolgt als switch-case Anweiszung innerhalb einer vorgesehene _.each Schleife Zurzeit ab Zeile 157.</p>
<pre><code class="language-js">
// View importieren
import ScaleView from &quot;../modules/tools/scale/view&quot;;
// View initialsieren
 _.each(Radio.request(&quot;ModelList&quot;, &quot;getModelsByAttributes&quot;, {type: &quot;tool&quot;}), function (tool) {
      switch (tool.id) {
          case &quot;scale&quot;: {
            new ScaleView({model: tool});
            break;
          }
          ... // weitere Tools
      }
  });


</code></pre>
<h3>Template erstellen</h3>
<p>Datei <em>modules/tools/scale/template.html</em> öffnen, Template coden und mit Bootstrap Klassen versehen</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;select class=&quot;form-control input-sm&quot;&gt;
  &lt;option&gt;1&lt;/option&gt;
  &lt;option&gt;2&lt;/option&gt;
  &lt;option&gt;3&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h3>Template in die View einbinden</h3>
<p>Das Template muss in die View eingebunden werden. Hierzu wird in einer neuen Variable (ScaleTemplate) das Template importiert und mithilfe von underscore (“_”) als Template zur Verfügung gestellt. Dieses Template wird dem View als Attribut “template” zugefügt.</p>
<pre><code class="language-js">
   import ScaleTemplate from &quot;text-loader!./template.html&quot;;


const ScaleView = Backbone.View.extend({
    initialize: function () {
    },
    // underscore template Funktion
    template: _.template(ScaleTemplate)
});

export default ScaleView;

</code></pre>
<h3>Template initial rendern</h3>
<p>Beim Laden der View, soll sich sofort das Tool in rendern wenn der Parameter “isActive” auf true gesetzt ist. Dazu wird in der initialize()-Funktion eine if-Abfrage definiert, welche die render-Funktion aufruft. Beim späteren aktivieren soll sich das Tool ebenfalls zeichnen. Dies wird über einen Listener realisert, der auf Verändeurngen des Paramters “isActive” wartet und anschließend die render-Funktion <a href="http://aufruft.In">aufruft.In</a> der render-Funktion passiert folgendes, wenn das Tool aktiv ist:
Die View wird and das HTML win-body gezeichnet.
Der View wird das Template zugefügt.</p>
<pre><code class="language-js">

const ScaleView = Backbone.View.extend({
    initialize: function () {
        this.listenTo(this.model, {
            &quot;change:isActive&quot;: this.render
        });
        if (this.model.get(&quot;isActive&quot;) === true) {
            this.render(this.model, true);
        }
    },
    template: _.template(ScaleTemplate),

    // Konvention: Die Methode fürs zeichnen der View, heißt render.
    render: function (model, value) {
        if (value) {
            this.setElement(document.getElementsByClassName(&quot;win-body&quot;)[0]);
            this.$el.html(this.template());
        }

        return this;
    }
});

export default ScaleView;

</code></pre>
<p>Jede View bekommt automatisch ein top level DOM Element (this.el) zugewiesen.
Standardeinstellung für das DOM Element ist ein <em>div</em> Tag. In diesem Fall zeichnet sich beim rendern ein <em>div</em> an den Body. Dieser <em>div</em> ist befüllt mit dem Inhalt des <em>templates</em>.</p>
<h3>scss Regeln definieren</h3>
<p>Datei <em>modules/tools/scale/style.scss</em> öffnen und folgenden Code eingeben.</p>
<pre><code class="language-css">.scale-switcher {
    border: 2px solid red;
}

Damit es keine Probleme mit scss Regeln anderer Module/Tools gibt, wird über eine definierte Klasse &quot;scale-switcher&quot; gestylt.
</code></pre>
<h3>Model erstellen und zurückgeben</h3>
<p>Datei <em>modules/tools/scale/model.js</em> öffnen und Model definieren. Das Model erbt vom der Elternklasse <em>Tool</em> das im Core <em>moduels/core/modelList/tool/model.js</em> definiert ist. Über den Aufruf der Funktion <em>superInitialize</em> wird der Listener, der die Aktivierung der Tools regelt, von der Elternklasse übernommen. Dem Parameter defaults werden alle Attribute mit einem Default-Wert eingetragen, die in diesem Model konfiguriert werden können (z.B. ein Glyphicon). Dort wird auch das Attribute “renderToWindow” auf true gestezt, damit sich der Scale-Switcher im vererbten Fenster zeichnet.</p>
<pre><code class="language-js">
import Tool from &quot;../../core/modelList/tool/model&quot;;

const ScaleModel = Tool.extend({
    defaults: _.extend({}, Tool.prototype.defaults, {
        glyphicon: &quot;glyphicon-resize-full&quot;,
        renderToWindow: true
    }),
    // wird aufgerufen wenn das Model erstellt wird
    initialize: function () {
        this.superInitialize();
    }
});

export default ScaleModel;

</code></pre>
<h3>Model der View zuweisen</h3>
<p>In der ModelList <em>modules/core/modelList/list.js</em> wird das Model import und unter dem Eintrag <em>model</em> in dem vorgesehenen if-else Statement per new ScaleModel() instanziiert.</p>
<pre><code class="language-js">
import ScaleModel from &quot;../../tools/scale/model&quot;;

 else if (attrs.type === &quot;tool&quot;) {
    else if (attrs.id === &quot;scale&quot;) {
        return new ScaleModel(attrs, options);
    }
    ... // weitere Tool-Models
 }

</code></pre>
<h3>Setter Methoden für das Model schreiben</h3>
<p>Mithilfe von Setter-Methoden werden Member-Variablen im Model definiert bzw überschrieben.
Dazu werden Default-Werte eingetragen.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    defaults: _.extend({}, Tool.prototype.defaults, {
        glyphicon: &quot;glyphicon-resize-full&quot;,
        renderToWindow: true,
        scales: &quot;&quot;,
        currentScale: &quot;&quot;
    },
    initialize: function () {
        this.superInitialize();
    },

    // Setter für alle verfügbaren Maßstäbe
    setScales: function (value) {
        this.set(&quot;scales&quot;, value);
    },
    // Setter für den aktuellen Maßstab
    setCurrentScale: function (value) {
        this.set(&quot;currentScale&quot;, value);
    }
});

export default ScaleModel;

</code></pre>
<h3>Maßstäbe der Karte abfragen und setzen</h3>
<p>Die Kommunikation mit anderen Modulen/Tools erfolgt über Backbone.Radio. In diesem Fall mit dem <em>MapView</em> Modul (<em>modules/core/mapView.js</em>), in dem alle Scales definiert sind. Das <em>MapView</em> Modul stellt bereits über Backbone.Radio die Funktion <em>getScales</em> zur Verfügung, über die alle Scales abgefragt werden können.
Diese Maßstäbe werden mittels <em>Radio</em> requested und im ScaleModel über die entsprechende Setter-Funktion gesetzt. Um sicher zu gehen, dass die <em>Map</em> bereits geladen ist wird ein Listener definiert, der auf eine entsprechende Nachricht wartet, bevor getScales getriggert wird.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        this.superInitialize();
        this.listenTo(Radio.channel(&quot;Map&quot;), {
            &quot;isReady&quot;: function () {
                // initial alle Scales der Karte abfragen
                this.setScales(Radio.request(&quot;MapView&quot;, &quot;getScales&quot;));
            }
        });
    },
    ...
});

export default ScaleModel;

</code></pre>
<h3>Aktuellen Kartenmaßstab abfragen und setzen</h3>
<p>Analog zu “getScales” können von der MapView auch der aktuelle Maßstab abgefragt werden. Hierzu werden die aktuellen Optionen requested und von diesem Objekt das Attribut “scale” verwendet. Dieses wird über den entsprechenden Setter als Model-Variable gesetzt.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        this.superInitialize();
        this.listenTo(Radio.channel(&quot;Map&quot;), {
            &quot;isReady&quot;: function () {
                ...
                this.setCurrentScale(Radio.request(&quot;MapView&quot;, &quot;getOptions&quot;).scale);
            }
        });
    },
    ...
});

export default ScaleModel;
</code></pre>
<h3>Model Attribute ans Template übergeben</h3>
<p>Da sich das Template dynamisch aus den Daten des Models erzeugen soll, muss die render()-Funktion erweitert werden. Indem das Model an das Template übergeben wird, können die Model-Variablen im Template verwendet werden.</p>
<pre><code class="language-js">
const ScaleView = Backbone.View.extend({
    initialize: function () {
        ...
    },
    template: _.template(ScaleTemplate),
    render: function (model, value) {
        // alle Model Attribute (currentScale, scales)
        var attr = model.toJSON();

        if (value) {
            this.setElement(document.getElementsByClassName(&quot;win-body&quot;)[0]);
            this.$el.html(this.template(attr));
        }

        return this;
    }
});

export default ScaleView;

</code></pre>
<h3>Maßstäbe in der View anzeigen bzw. ins Template scripten</h3>
<p>Im Tag “select” wird die Klasse “scale-switcher” definiert.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;select class=&quot;form-control input-sm scale-switcher&quot;&gt;
  &lt;% _.each(scales, function (scale) { %&gt;
    &lt;% if (scale === currentScale) { %&gt;
        &lt;option selected&gt;&lt;%= scale %&gt;&lt;/option&gt;
    &lt;% }
    else { %&gt;
        &lt;option&gt;&lt;%= scale %&gt;&lt;/option&gt;
    &lt;% } %&gt;
  &lt;% }); %&gt;
&lt;/select&gt;
</code></pre>
<h3>User Input in der View registrieren</h3>
<p>In der View haben wir die Möglichkeit auf events im HTML zu hören. In diesem Fall wollen wir darauf hören, wenn sich im Drop-Down-Menü ein Eintrag geändert hat. Wenn dieses Event eintrifft, überschreiben wir im Model das Attribut “currentScale” mit dem Wert aus dem Drop-Down-Menü. Dafür verwenden wir die Setter-Methode “setCurrentScale” des Models.</p>
<pre><code class="language-js">
const ScaleView = Backbone.View.extend({
    ...,
    events: {
        // DOM Change Event führt this.setCurrentScale aus
        &quot;change .form-control&quot;: &quot;setCurrentScale&quot;
    },
    initialize: function () {...},
    template: _.template(ScaleTemplate),
    render: function () {...},
    // Ruft im Model die Methode setCurrentScale auf
    setCurrentScale: function (evt) {
        this.model.setCurrentScale(parseInt(evt.target.value, 10));
    }
});

export default ScaleView;
</code></pre>
<h3>Model Listener auf change:currentScale</h3>
<p>Durch einen Listener wird bei Veränderung der currentScale der neue Maßstab an die Mapview gesendet. Das Attribut “currentScale” wird über die Getter-Funktion von Backbone geholt.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        ...
        this.listenTo(this, {
            &quot;change:currentScale&quot;: function () {
                // Sendet den neuen Maßstab an die MapView
                // Dadurch zoomt die Karte in diesen Maßstab
                Radio.trigger(&quot;MapView&quot;, &quot;setScale&quot;, this.get(&quot;currentScale&quot;));
            }
        });
        ...
    },
    setScales: function (value) {...},
    setCurrentScale: function (value) {...}
});

export default ScaleModel;
</code></pre>
<h3>Model Listener auf MapView changedOptions</h3>
<p>Wir wollen nicht nur den Maßstab der Karte setzen können , sondern auch auf Veränderungen des Maßstabs reagieren. Ändert sich der Kartenmaßstab, soll sich in unserem Tool der aktuelle Maßstab anpassen.
Dazu wird in der Initialize-Funktion ein Listener geschrieben. Dieser Hört per Radio auf ein “changedOptions”-Event des Radio-Channels “MapView”. Sobald ein solches Event getriggert wird, wird mithilfe unserer Setter-Methode <em>setCurrentScale()</em> der aktuelle Maßstab im Model überschrieben.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        ...
        this.listenTo(Radio.channel(&quot;MapView&quot;), {
            // Wird ausgelöst wenn sich Zoomlevel, Center
            // oder Resolution der Karte ändert
            &quot;changedOptions&quot;: function (value) {
                this.setCurrentScale(value.scale);
            }
        });
        ...
    },
    ...
});

export default ScaleModel;
</code></pre>
<h3>View Listener auf change currentScale im Model</h3>
<p>Bisher erkennt nur das Model eine Veränderung des aktuellen Kartenmaßstabes. Die View muss jedoch auch darauf hören, wenn sich in seinem Model der aktuelle Maßstab verändert. Denn dann muss sich das Tool neu zeichnen, sodass der aktuelle Maßstab angezeigt wird.</p>
<pre><code class="language-js">const ScaleView = Backbone.View.extend({
    ...
    events: {...}
    initialize: function () {
        this.listenTo(this.model, {
            // Verändert sich der Maßstab der Karte und damit der currentScale
            // des Models, wird die View neu gezeichnet.
            &quot;change:currentScale&quot;: this.render
        });
        ...
    },
    render: function () {...},
    setCurrentScale: function (evt) {...}
});

export default ScaleView;

</code></pre>
<h3>Tool in der config.json konfigurieren</h3>
<p>Um das Tool in einem Portal zu verwenden, muss dies in der config.json konfiguriert werden</p>
<pre><code class="language-js">      &quot;tools&quot;:
      {
        &quot;name&quot;: &quot;Werkzeuge&quot;,
        &quot;glyphicon&quot;: &quot;glyphicon-wrench&quot;,
        &quot;children&quot;: {
          &quot;scale&quot;:
          {
            &quot;name&quot;: &quot;Scale Switcher&quot;,
            &quot;glyphicon&quot;: &quot;glyphicon-resize-full&quot;
          },
          ... // weitere Tools
        }
      }
</code></pre>
